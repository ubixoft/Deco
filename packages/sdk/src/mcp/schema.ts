import {
  pgTable,
  serial,
  text,
  timestamp,
  uuid,
  integer,
  bigint,
  jsonb,
  uniqueIndex,
  real,
  pgEnum,
  boolean,
  index,
} from "drizzle-orm/pg-core";
import { WELL_KNOWN_PLANS } from "../plan";
import type { MCPConnection, Statement } from "../models";

/**
 * create table public.deco_chat_plans (
  id uuid not null,
  title text not null,
  markup integer not null,
  user_seats integer not null,
  monthly_credit_in_dollars integer not null,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp without time zone null default CURRENT_TIMESTAMP,
  constraint deco_chat_plans_pkey primary key (id)
) TABLESPACE pg_default;
 */

export const plans = pgTable("deco_chat_plans", {
  id: uuid("id").primaryKey(),
  title: text("title").notNull(),
  markup: integer("markup").notNull(),
  user_seats: integer("user_seats").notNull(),
  monthly_credit_in_dollars: integer("monthly_credit_in_dollars").notNull(),
  created_at: timestamp("created_at").defaultNow(),
  updated_at: timestamp("updated_at").defaultNow(),
});

/**
 * create table public.teams (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone null default now(),
  name text not null,
  stripe_subscription_id text null,
  slug text null,
  plan text null,
  theme jsonb null,
  plan_id uuid not null default '00000000-0000-0000-0000-000000000001'::uuid,
  constraint Organizations_pkey primary key (id),
  constraint teams_slug_key unique (slug),
  constraint teams_plan_id_fkey foreign KEY (plan_id) references deco_chat_plans (id)
) TABLESPACE pg_default;
 */

export const organizations = pgTable("teams", {
  id: serial("id").primaryKey(),
  created_at: timestamp("created_at").defaultNow(),
  name: text("name").notNull(),
  stripe_subscription_id: text("stripe_subscription_id"),
  slug: text("slug").unique(),
  plan: text("plan"),
  theme: jsonb("theme"),
  plan_id: uuid("plan_id")
    .notNull()
    .default(WELL_KNOWN_PLANS.FREE)
    .references(() => plans.id),
});

/**
 * create table public.deco_chat_projects (
  id uuid not null default gen_random_uuid (),
  slug text not null,
  title text not null,
  icon text null,
  description text null,
  org_id bigint not null,
  created_at timestamp without time zone null default now(),
  constraint deco_chat_projects_pkey primary key (id),
  constraint deco_chat_projects_slug_org_id_unique unique (slug, org_id),
  constraint deco_chat_projects_org_id_fkey foreign KEY (org_id) references teams (id)
) TABLESPACE pg_default;
 */

export const projects = pgTable(
  "deco_chat_projects",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    slug: text("slug").notNull(),
    title: text("title").notNull(),
    icon: text("icon"),
    description: text("description"),
    org_id: bigint("org_id", { mode: "number" })
      .notNull()
      .references(() => organizations.id),
    created_at: timestamp("created_at", { mode: "string" })
      .defaultNow()
      .notNull(),
  },
  (table) => [
    uniqueIndex("deco_chat_projects_slug_org_id_unique").on(
      table.slug,
      table.org_id,
    ),
  ],
);

/**
 * create table public.deco_chat_access (
  id uuid not null default gen_random_uuid (),
  visibility public.deco_chat_visibility_type not null default 'private'::deco_chat_visibility_type,
  owner_id uuid not null,
  allowed_roles text[] null default '{}'::text[],
  constraint deco_chat_access_pkey primary key (id)
) TABLESPACE pg_default;

create index IF not exists idx_deco_chat_access_owner on public.deco_chat_access using btree (owner_id) TABLESPACE pg_default;
*/

export const decoVisibilityType = pgEnum("deco_chat_visibility_type", [
  "public",
  "private",
  "role_based",
]);

export const access = pgTable("deco_chat_access", {
  id: uuid("id").primaryKey().defaultRandom(),
  visibility: decoVisibilityType("visibility").notNull().default("private"),
  owner_id: uuid("owner_id").notNull(),
  allowed_roles: text("allowed_roles").array(),
});

/**
 * create table public.deco_chat_agents (
  id uuid not null default gen_random_uuid (),
  name text not null,
  avatar text not null,
  instructions text not null,
  description text null,
  tools_set jsonb not null,
  max_steps integer null,
  max_tokens integer null,
  model text not null,
  memory jsonb null,
  views jsonb not null,
  created_at timestamp with time zone not null default now(),
  workspace text not null,
  visibility public.visibility_type not null default 'WORKSPACE'::visibility_type,
  access text null,
  access_id uuid null,
  temperature real null,
  project_id uuid null,
  constraint deco_chat_agents_pkey primary key (id),
  constraint deco_chat_agents_access_id_fkey foreign KEY (access_id) references deco_chat_access (id) on delete CASCADE,
  constraint fk_deco_chat_agents_project_id foreign KEY (project_id) references deco_chat_projects (id) on delete set null
) TABLESPACE pg_default;
 */

export const visibilityType = pgEnum("visibility_type", [
  "PUBLIC",
  "WORKSPACE",
  "PRIVATE",
]);

export const agents = pgTable("deco_chat_agents", {
  id: uuid("id").primaryKey().defaultRandom(),
  name: text("name").notNull(),
  avatar: text("avatar").notNull(),
  instructions: text("instructions").notNull(),
  description: text("description"),
  tools_set: jsonb("tools_set").notNull(),
  max_steps: integer("max_steps"),
  max_tokens: integer("max_tokens"),
  model: text("model").notNull(),
  memory: jsonb("memory"),
  views: jsonb("views").notNull(),
  created_at: timestamp("created_at").defaultNow(),
  workspace: text("workspace"),
  temperature: real("temperature"),
  visibility: visibilityType("visibility").notNull().default("WORKSPACE"),
  access: text("access"),
  access_id: uuid("access_id").references(() => access.id),
  project_id: uuid("project_id").references(() => projects.id),
});

/**
 * create table public.deco_chat_apps_registry (
  id uuid not null default gen_random_uuid (),
  workspace text not null,
  scope_id uuid not null,
  name text not null,
  description text null,
  icon text null,
  connection jsonb not null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  unlisted boolean not null default false,
  friendly_name text null,
  verified boolean null default false,
  metadata jsonb null,
  project_id uuid null,
  constraint deco_chat_apps_registry_pkey primary key (id),
  constraint unique_registry_app_scope_name unique (scope_id, name),
  constraint deco_chat_apps_registry_scope_id_fkey foreign KEY (scope_id) references deco_chat_registry_scopes (id) on delete CASCADE,
  constraint fk_deco_chat_apps_registry_project_id foreign KEY (project_id) references deco_chat_projects (id) on delete set null
) TABLESPACE pg_default;

create index IF not exists idx_registry_apps_workspace on public.deco_chat_apps_registry using btree (workspace) TABLESPACE pg_default;

create index IF not exists idx_registry_apps_scope_id on public.deco_chat_apps_registry using btree (scope_id) TABLESPACE pg_default;

create index IF not exists idx_registry_apps_name on public.deco_chat_apps_registry using btree (name) TABLESPACE pg_default;
 */

export const registryApps = pgTable(
  "deco_chat_apps_registry",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    workspace: text("workspace"),
    scope_id: uuid("scope_id")
      .notNull()
      .references(() => registryScopes.id),
    name: text("name").notNull(),
    description: text("description"),
    icon: text("icon"),
    connection: jsonb("connection").$type<MCPConnection>().notNull(),
    created_at: timestamp("created_at", { mode: "string" })
      .defaultNow()
      .notNull(),
    updated_at: timestamp("updated_at", { mode: "string" })
      .defaultNow()
      .notNull(),
    unlisted: boolean("unlisted").notNull().default(false),
    friendly_name: text("friendly_name"),
    verified: boolean("verified").default(false),
    metadata: jsonb("metadata").$type<Record<string, unknown>>(),
    project_id: uuid("project_id").references(() => projects.id),
  },
  (table) => [
    uniqueIndex("unique_registry_app_scope_name").on(
      table.scope_id,
      table.name,
    ),
  ],
);

/**
 * create table public.deco_chat_apps_registry_tools (
  id uuid not null default gen_random_uuid (),
  app_id uuid not null,
  name text not null,
  description text null,
  input_schema jsonb null,
  output_schema jsonb null,
  metadata jsonb null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint deco_chat_apps_registry_tools_pkey primary key (id),
  constraint unique_registry_tool_app_name unique (app_id, name),
  constraint deco_chat_apps_registry_tools_app_id_fkey foreign KEY (app_id) references deco_chat_apps_registry (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_registry_tools_app_id on public.deco_chat_apps_registry_tools using btree (app_id) TABLESPACE pg_default;

create index IF not exists idx_registry_tools_name on public.deco_chat_apps_registry_tools using btree (name) TABLESPACE pg_default;
 */

export const registryTools = pgTable(
  "deco_chat_apps_registry_tools",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    app_id: uuid("app_id")
      .notNull()
      .references(() => registryApps.id),
    name: text("name").notNull(),
    description: text("description"),
    input_schema: jsonb("input_schema").$type<Record<string, unknown>>(),
    output_schema: jsonb("output_schema").$type<Record<string, unknown>>(),
    metadata: jsonb("metadata").$type<Record<string, unknown>>(),
    created_at: timestamp("created_at", { mode: "string" }).defaultNow(),
    updated_at: timestamp("updated_at", { mode: "string" }).defaultNow(),
  },
  (table) => [
    uniqueIndex("unique_registry_tool_app_name").on(table.app_id, table.name),
  ],
);

/**
 * create table public.deco_chat_registry_scopes (
  id uuid not null default gen_random_uuid (),
  scope_name text not null,
  workspace text not null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  project_id uuid null,
  constraint deco_chat_registry_scopes_pkey primary key (id),
  constraint deco_chat_registry_scopes_scope_name_key unique (scope_name),
  constraint fk_deco_chat_registry_scopes_project_id foreign KEY (project_id) references deco_chat_projects (id) on delete set null
) TABLESPACE pg_default;

create index IF not exists idx_registry_scopes_scope_name on public.deco_chat_registry_scopes using btree (scope_name) TABLESPACE pg_default;

create index IF not exists idx_registry_scopes_workspace on public.deco_chat_registry_scopes using btree (workspace) TABLESPACE pg_default;
 */

export const registryScopes = pgTable(
  "deco_chat_registry_scopes",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    scope_name: text("scope_name").notNull().unique(),
    workspace: text("workspace"),
    created_at: timestamp("created_at", { mode: "string" })
      .defaultNow()
      .notNull(),
    updated_at: timestamp("updated_at", { mode: "string" })
      .defaultNow()
      .notNull(),
    project_id: uuid("project_id").references(() => projects.id),
  },
  (table) => [
    uniqueIndex("deco_chat_registry_scopes_scope_name_key").on(
      table.scope_name,
    ),
  ],
);

/**
 * create table public.deco_chat_integrations (
  id uuid not null default gen_random_uuid (),
  name text not null,
  description text null,
  icon text null,
  connection jsonb not null,
  created_at timestamp with time zone not null default now(),
  workspace text not null,
  access text null,
  access_id uuid null,
  app_id uuid null,
  project_id uuid null,
  constraint deco_chat_integrations_pkey primary key (id),
  constraint deco_chat_integrations_access_id_fkey foreign KEY (access_id) references deco_chat_access (id) on delete CASCADE,
  constraint deco_chat_integrations_app_id_fkey foreign KEY (app_id) references deco_chat_apps_registry (id),
  constraint fk_deco_chat_integrations_project_id foreign KEY (project_id) references deco_chat_projects (id) on delete set null
) TABLESPACE pg_default;

create index IF not exists idx_integrations_app_id on public.deco_chat_integrations using btree (app_id) TABLESPACE pg_default;
 */

export const integrations = pgTable("deco_chat_integrations", {
  id: uuid("id").primaryKey().defaultRandom(),
  name: text("name").notNull(),
  description: text("description"),
  icon: text("icon"),
  connection: jsonb("connection").notNull(),
  created_at: timestamp("created_at").defaultNow(),
  workspace: text("workspace"),
  access: text("access"),
  access_id: uuid("access_id").references(() => access.id),
  app_id: uuid("app_id").references(() => registryApps.id),
  project_id: uuid("project_id").references(() => projects.id),
});

/**
 * create table public.deco_chat_api_keys (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  workspace text NOT NULL,
  enabled boolean NOT NULL DEFAULT true,
  policies jsonb DEFAULT '{}',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  deleted_at timestamptz,
  project_id uuid NULL,
  CONSTRAINT unique_api_key_name_workspace UNIQUE(name, workspace),
  CONSTRAINT fk_deco_chat_api_keys_project_id FOREIGN KEY (project_id) REFERENCES deco_chat_projects (id) ON DELETE SET NULL
) TABLESPACE pg_default;
 */

export const apiKeys = pgTable(
  "deco_chat_api_keys",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    name: text("name").notNull(),
    workspace: text("workspace"),
    enabled: boolean("enabled").notNull().default(true),
    policies: jsonb("policies").$type<Statement[]>(),
    created_at: timestamp("created_at", { mode: "string" })
      .defaultNow()
      .notNull(),
    updated_at: timestamp("updated_at", { mode: "string" })
      .defaultNow()
      .notNull(),
    deleted_at: timestamp("deleted_at", { mode: "string" }),
    project_id: uuid("project_id").references(() => projects.id),
  },
  (table) => [
    uniqueIndex("unique_api_key_name_workspace").on(
      table.name,
      table.workspace,
    ),
  ],
);

/**
 * create table public.profiles (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone null default now(),
  name text null,
  user_id uuid not null,
  email character varying not null,
  deco_user_id bigint null,
  is_new_user boolean null,
  phone text null,
  phone_verified_at timestamp with time zone null,
  constraint profiles_pkey primary key (id),
  constraint profiles_user_id_key unique (user_id),
  constraint profiles_user_id_fkey foreign KEY (user_id) references auth.users (id),
  constraint public_profiles_deco_user_id_fkey foreign KEY (deco_user_id) references deco_users (id)
) TABLESPACE pg_default;

create index IF not exists idx_profiles_user_id on public.profiles using btree (user_id) TABLESPACE pg_default;
 */

export const profiles = pgTable(
  "profiles",
  {
    id: bigint("id", { mode: "bigint" }).primaryKey(),
    created_at: timestamp("created_at").defaultNow(),
    name: text("name"),
    user_id: uuid("user_id").notNull(), // .references(() => users.id),
    email: text("email").notNull(),
    // deco_user_id: bigint("deco_user_id", { mode: "bigint" }).references(() => decoUsers.id),
    is_new_user: boolean("is_new_user"),
    phone: text("phone"),
    phone_verified_at: timestamp("phone_verified_at"),
  },
  (table) => [uniqueIndex("profiles_user_id_key").on(table.user_id)],
);

/**
 * create table public.user_activity (
  created_at timestamp with time zone not null default now(),
  user_id uuid not null,
  resource text not null,
  key text null,
  value text null,
  id bigint generated by default as identity not null,
  constraint user_activity_pkey primary key (id),
  constraint user_opened_user_id_fkey foreign KEY (user_id) references profiles (user_id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists user_activity_resource_key_value_idx on public.user_activity using btree (resource, key, value) TABLESPACE pg_default;

create index IF not exists user_activity_user_id_created_at_idx on public.user_activity using btree (user_id, created_at desc) TABLESPACE pg_default;
 */

export const userActivity = pgTable(
  "user_activity",
  {
    id: bigint("id", { mode: "bigint" }).primaryKey(),
    created_at: timestamp("created_at").defaultNow(),
    user_id: uuid("user_id")
      .notNull()
      .references(() => profiles.user_id),
    resource: text("resource").notNull(),
    key: text("key"),
    value: text("value"),
  },
  (table) => [
    index("user_activity_resource_key_value_idx").on(
      table.resource,
      table.key,
      table.value,
    ),
    index("user_activity_user_id_created_at_idx").on(
      table.user_id,
      table.created_at,
    ),
  ],
);

/**
 * create table public.members (
  id bigint generated by default as identity not null,
  user_id uuid not null,
  team_id bigint not null,
  admin boolean not null default false,
  created_at timestamp with time zone not null default now(),
  deleted_at timestamp with time zone null,
  constraint members_pkey primary key (id),
  constraint members_team_id_fkey foreign key (team_id) references teams (id) on delete cascade,
  constraint members_user_id_fkey foreign key (user_id) references auth.users (id) on delete cascade
) tablespace pg_default;
 */

export const members = pgTable(
  "members",
  {
    id: serial("id").primaryKey(),
    user_id: uuid("user_id").notNull(),
    team_id: bigint("team_id", { mode: "number" })
      .notNull()
      .references(() => organizations.id, { onDelete: "cascade" }),
    admin: boolean("admin").notNull().default(false),
    created_at: timestamp("created_at").defaultNow().notNull(),
    deleted_at: timestamp("deleted_at"),
  },
  (table) => [
    index("idx_members_team_id").on(table.team_id),
    index("idx_members_user_id").on(table.user_id),
  ],
);

/**
 * create table public.roles (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  name text not null,
  description text null,
  team_id bigint null,
  statements jsonb[] null,
  constraint roles_pkey primary key (id),
  constraint roles_team_id_fkey foreign KEY (team_id) references teams (id)
) TABLESPACE pg_default;
 */

export const roles = pgTable(
  "roles",
  {
    id: serial("id").primaryKey(),
    created_at: timestamp("created_at", { mode: "string" })
      .defaultNow()
      .notNull(),
    name: text("name").notNull(),
    description: text("description"),
    team_id: bigint("team_id", { mode: "number" }).references(
      () => organizations.id,
    ),
    statements: jsonb("statements").$type<Statement[]>(),
  },
  (table) => [index("roles_team_id_fkey").on(table.team_id)],
);

/**
 * create table public.member_roles (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  member_id bigint not null,
  role_id bigint not null,
  constraint member_roles_pkey primary key (id),
  constraint unique_member_role unique (role_id, member_id),
  constraint member_roles_member_id_fkey foreign KEY (member_id) references members (id),
  constraint member_roles_role_id_fkey foreign KEY (role_id) references roles (id)
) TABLESPACE pg_default;
 */

export const memberRoles = pgTable(
  "member_roles",
  {
    id: serial("id").primaryKey(),
    created_at: timestamp("created_at", { mode: "string" })
      .defaultNow()
      .notNull(),
    member_id: bigint("member_id", { mode: "number" })
      .notNull()
      .references(() => members.id),
    role_id: bigint("role_id", { mode: "number" })
      .notNull()
      .references(() => roles.id),
  },
  (table) => [
    uniqueIndex("unique_member_role").on(table.role_id, table.member_id),
  ],
);

/**
 * create table public.deco_chat_issues (
  id uuid not null default gen_random_uuid(),
  org_id bigint null,
  project_id uuid null,
  reporter_user_id uuid not null,
  type text not null,
  content text not null,
  url text null,
  path text null,
  created_at timestamp with time zone not null default now(),
  constraint deco_chat_issues_pkey primary key (id),
  constraint deco_chat_issues_org_id_fkey foreign key (org_id) references teams (id) on delete cascade,
  constraint deco_chat_issues_project_id_fkey foreign key (project_id) references deco_chat_projects (id) on delete set null,
  constraint deco_chat_issues_reporter_user_id_fkey foreign key (reporter_user_id) references auth.users (id) on delete cascade
) tablespace pg_default;
 */

export const issues = pgTable(
  "deco_chat_issues",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    org_id: bigint("org_id", { mode: "number" }).references(
      () => organizations.id,
      { onDelete: "cascade" },
    ),
    project_id: uuid("project_id").references(() => projects.id, {
      onDelete: "set null",
    }),
    reporter_user_id: uuid("reporter_user_id").notNull(),
    type: text("type").$type<"Bug" | "Idea">().notNull(),
    content: text("content").notNull(),
    url: text("url"),
    path: text("path"),
    created_at: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("idx_deco_chat_issues_org_id").on(table.org_id),
    index("idx_deco_chat_issues_reporter_user_id").on(table.reporter_user_id),
    index("idx_deco_chat_issues_created_at").on(table.created_at),
  ],
);

/**
 * create table public.deco_chat_triggers (
  id uuid not null default gen_random_uuid (),
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  workspace text not null,
  agent_id text not null,
  metadata jsonb not null,
  user_id uuid null,
  active boolean not null default true,
  binding_id uuid null,
  access_id uuid null,
  project_id uuid null,
  constraint deco_chat_triggers_pkey primary key (id),
  constraint deco_chat_triggers_access_id_fkey foreign KEY (access_id) references deco_chat_access (id) on delete CASCADE,
  constraint deco_chat_triggers_binding_id_fkey foreign KEY (binding_id) references deco_chat_integrations (id),
  constraint deco_chat_triggers_user_id_fkey foreign KEY (user_id) references profiles (user_id),
  constraint fk_deco_chat_triggers_project_id foreign KEY (project_id) references deco_chat_projects (id) on delete set null
) TABLESPACE pg_default;
 */

export const triggers = pgTable(
  "deco_chat_triggers",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    created_at: timestamp("created_at").defaultNow(),
    updated_at: timestamp("updated_at").defaultNow(),
    workspace: text("workspace"),
    agent_id: uuid("agent_id")
      .notNull()
      .references(() => agents.id),
    metadata: jsonb("metadata").notNull(),
    user_id: uuid("user_id").references(() => profiles.user_id),
    active: boolean("active").notNull().default(true),
    binding_id: uuid("binding_id").references(() => integrations.id),
    access_id: uuid("access_id").references(() => access.id),
    project_id: uuid("project_id").references(() => projects.id),
  },
  (table) => [
    index("idx_deco_chat_triggers_access_id").on(table.access_id),
    index("idx_deco_chat_triggers_binding_id").on(table.binding_id),
    index("idx_deco_chat_triggers_user_id").on(table.user_id),
    index("idx_deco_chat_triggers_project_id").on(table.project_id),
  ],
);

export const customers = pgTable("deco_chat_customer", {
  customer_id: text("customer_id").notNull(),
  created_at: timestamp("created_at").defaultNow().notNull(),
  org_id: bigint("org_id", { mode: "number" }).references(
    () => organizations.id,
  ),
});

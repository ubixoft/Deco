import {
  pgTable,
  serial,
  text,
  timestamp,
  uuid,
  integer,
  bigint,
  jsonb,
  uniqueIndex,
  real,
  pgEnum,
} from "drizzle-orm/pg-core";
import { WELL_KNOWN_PLANS } from "../plan";
import { sql } from "drizzle-orm";

/**
 * create table public.deco_chat_plans (
  id uuid not null,
  title text not null,
  markup integer not null,
  user_seats integer not null,
  monthly_credit_in_dollars integer not null,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp without time zone null default CURRENT_TIMESTAMP,
  constraint deco_chat_plans_pkey primary key (id)
) TABLESPACE pg_default;
 */

export const plans = pgTable("deco_chat_plans", {
  id: uuid("id").primaryKey(),
  title: text("title").notNull(),
  markup: integer("markup").notNull(),
  user_seats: integer("user_seats").notNull(),
  monthly_credit_in_dollars: integer("monthly_credit_in_dollars").notNull(),
  created_at: timestamp("created_at").defaultNow(),
  updated_at: timestamp("updated_at").defaultNow(),
});

/**
 * create table public.teams (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone null default now(),
  name text not null,
  stripe_subscription_id text null,
  slug text null,
  plan text null,
  theme jsonb null,
  plan_id uuid not null default '00000000-0000-0000-0000-000000000001'::uuid,
  constraint Organizations_pkey primary key (id),
  constraint teams_slug_key unique (slug),
  constraint teams_plan_id_fkey foreign KEY (plan_id) references deco_chat_plans (id)
) TABLESPACE pg_default;
 */

export const organizations = pgTable("teams", {
  id: serial("id").primaryKey(),
  created_at: timestamp("created_at").defaultNow(),
  name: text("name").notNull(),
  stripe_subscription_id: text("stripe_subscription_id"),
  slug: text("slug").unique(),
  plan: text("plan"),
  theme: jsonb("theme"),
  plan_id: uuid("plan_id")
    .notNull()
    .default(WELL_KNOWN_PLANS.FREE)
    .references(() => plans.id),
});

/**
 * create table public.deco_chat_projects (
  id uuid not null default gen_random_uuid (),
  slug text not null,
  title text not null,
  icon text null,
  description text null,
  org_id bigint not null,
  created_at timestamp without time zone null default now(),
  constraint deco_chat_projects_pkey primary key (id),
  constraint deco_chat_projects_slug_org_id_unique unique (slug, org_id),
  constraint deco_chat_projects_org_id_fkey foreign KEY (org_id) references teams (id)
) TABLESPACE pg_default;
 */

export const projects = pgTable(
  "deco_chat_projects",
  {
    id: uuid("id").primaryKey().default(sql`gen_random_uuid ()`),
    slug: text("slug").notNull(),
    title: text("title").notNull(),
    icon: text("icon"),
    description: text("description"),
    org_id: bigint("org_id", { mode: "bigint" })
      .notNull()
      .references(() => organizations.id),
    created_at: timestamp("created_at").defaultNow(),
  },
  (table) => [
    uniqueIndex("deco_chat_projects_slug_org_id_unique").on(
      table.slug,
      table.org_id,
    ),
  ],
);

/**
 * create table public.deco_chat_access (
  id uuid not null default gen_random_uuid (),
  visibility public.deco_chat_visibility_type not null default 'private'::deco_chat_visibility_type,
  owner_id uuid not null,
  allowed_roles text[] null default '{}'::text[],
  constraint deco_chat_access_pkey primary key (id)
) TABLESPACE pg_default;

create index IF not exists idx_deco_chat_access_owner on public.deco_chat_access using btree (owner_id) TABLESPACE pg_default;
*/

export const decoVisibilityType = pgEnum("deco_chat_visibility_type", [
  "public",
  "private",
  "role_based",
]);

export const access = pgTable("deco_chat_access", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid ()`),
  visibility: decoVisibilityType("visibility").notNull().default("private"),
  owner_id: uuid("owner_id").notNull(),
  allowed_roles: text("allowed_roles").array(),
});

/**
 * create table public.deco_chat_agents (
  id uuid not null default gen_random_uuid (),
  name text not null,
  avatar text not null,
  instructions text not null,
  description text null,
  tools_set jsonb not null,
  max_steps integer null,
  max_tokens integer null,
  model text not null,
  memory jsonb null,
  views jsonb not null,
  created_at timestamp with time zone not null default now(),
  workspace text not null,
  visibility public.visibility_type not null default 'WORKSPACE'::visibility_type,
  access text null,
  access_id uuid null,
  temperature real null,
  project_id uuid null,
  constraint deco_chat_agents_pkey primary key (id),
  constraint deco_chat_agents_access_id_fkey foreign KEY (access_id) references deco_chat_access (id) on delete CASCADE,
  constraint fk_deco_chat_agents_project_id foreign KEY (project_id) references deco_chat_projects (id) on delete set null
) TABLESPACE pg_default;
 */

export const visibilityType = pgEnum("visibility_type", [
  "PUBLIC",
  "WORKSPACE",
  "PRIVATE",
]);

export const agents = pgTable("deco_chat_agents", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid ()`),
  name: text("name").notNull(),
  avatar: text("avatar").notNull(),
  instructions: text("instructions").notNull(),
  description: text("description"),
  tools_set: jsonb("tools_set").notNull(),
  max_steps: integer("max_steps"),
  max_tokens: integer("max_tokens"),
  model: text("model").notNull(),
  memory: jsonb("memory"),
  views: jsonb("views").notNull(),
  created_at: timestamp("created_at").defaultNow(),
  workspace: text("workspace").notNull(),
  temperature: real("temperature"),
  visibility: visibilityType("visibility").notNull().default("WORKSPACE"),
  access: text("access"),
  access_id: uuid("access_id").references(() => access.id),
  project_id: uuid("project_id").references(() => projects.id),
});

/**
 * create table public.deco_chat_integrations (
  id uuid not null default gen_random_uuid (),
  name text not null,
  description text null,
  icon text null,
  connection jsonb not null,
  created_at timestamp with time zone not null default now(),
  workspace text not null,
  access text null,
  access_id uuid null,
  app_id uuid null,
  project_id uuid null,
  constraint deco_chat_integrations_pkey primary key (id),
  constraint deco_chat_integrations_access_id_fkey foreign KEY (access_id) references deco_chat_access (id) on delete CASCADE,
  constraint deco_chat_integrations_app_id_fkey foreign KEY (app_id) references deco_chat_apps_registry (id),
  constraint fk_deco_chat_integrations_project_id foreign KEY (project_id) references deco_chat_projects (id) on delete set null
) TABLESPACE pg_default;

create index IF not exists idx_integrations_app_id on public.deco_chat_integrations using btree (app_id) TABLESPACE pg_default;
 */

export const integrations = pgTable("deco_chat_integrations", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid ()`),
  name: text("name").notNull(),
  description: text("description"),
  icon: text("icon"),
  connection: jsonb("connection").notNull(),
  created_at: timestamp("created_at").defaultNow(),
  workspace: text("workspace").notNull(),
  access: text("access"),
  access_id: uuid("access_id").references(() => access.id),
  //   app_id: uuid("app_id").references(() => apps.id),
  project_id: uuid("project_id").references(() => projects.id),
});

---
description: 
globs: 
alwaysApply: true
---

    You are an expert in TypeScript, Vite, React, and Tailwind and Shadcn, with a deep understanding of best practices and performance optimization techniques in these technologies.
  
    Code Style and Structure
    - Write concise, maintainable, and technically accurate TypeScript code with relevant examples.
    - Use functional and declarative programming patterns; avoid classes.
    - Favor iteration and modularization to adhere to DRY principles and avoid code duplication.
    - Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
    - Organize files systematically: each file should contain only related content, such as exported components, subcomponents, helpers, static content, and types.
  
    Naming Conventions
    - Use lowercase with dashes for directories (e.g., components/auth-wizard).
    - Favor named exports for functions.
  
    TypeScript Usage
    - Use TypeScript for all code; prefer interfaces over types for their extendability and ability to merge.
    - Avoid enums; use maps instead for better type safety and flexibility.
    - Use functional components with TypeScript interfaces.
  
    Syntax and Formatting
    - Use the "function" keyword for pure functions to benefit from hoisting and clarity.
  
    UI and Styling
    - Favor to use the already-present ui components in `packages/ui` folder.
    - This the available components in the `packages/ui`.
        ├── src
        │   ├── components
        │   │   ├── accordion.tsx
        │   │   ├── alert-dialog.tsx
        │   │   ├── alert.tsx
        │   │   ├── aspect-ratio.tsx
        │   │   ├── avatar.tsx
        │   │   ├── badge.tsx
        │   │   ├── breadcrumb.tsx
        │   │   ├── button.tsx
        │   │   ├── calendar.tsx
        │   │   ├── card.tsx
        │   │   ├── carousel.tsx
        │   │   ├── chart.tsx
        │   │   ├── checkbox.tsx
        │   │   ├── collapsible.tsx
        │   │   ├── command.tsx
        │   │   ├── context-menu.tsx
        │   │   ├── dialog.tsx
        │   │   ├── drawer.tsx
        │   │   ├── dropdown-menu.tsx
        │   │   ├── form.tsx
        │   │   ├── hover-card.tsx
        │   │   ├── icon.tsx
        │   │   ├── input-otp.tsx
        │   │   ├── input.tsx
        │   │   ├── label.tsx
        │   │   ├── menubar.tsx
        │   │   ├── navigation-menu.tsx
        │   │   ├── pagination.tsx
        │   │   ├── popover.tsx
        │   │   ├── progress.tsx
        │   │   ├── radio-group.tsx
        │   │   ├── resizable.tsx
        │   │   ├── scroll-area.tsx
        │   │   ├── select.tsx
        │   │   ├── separator.tsx
        │   │   ├── sheet.tsx
        │   │   ├── sidebar.tsx
        │   │   ├── skeleton.tsx
        │   │   ├── slider.tsx
        │   │   ├── sonner.tsx
        │   │   ├── spinner.tsx
        │   │   ├── switch.tsx
        │   │   ├── table.tsx
        │   │   ├── tabs.tsx
        │   │   ├── textarea.tsx
        │   │   ├── toggle-group.tsx
        │   │   ├── toggle.tsx
        │   │   └── tooltip.tsx


## React Best Practices

### Performance Optimization
This application is data-intensive and render-intensive. Optimize performance by:

**useMemo for Expensive Computations:**
```tsx
// ✅ Good - Memoize expensive filtering/sorting operations
const filteredAgents = useMemo(() => {
  return agents.filter(agent => 
    agent.name.toLowerCase().includes(searchTerm.toLowerCase())
  ).sort((a, b) => a.name.localeCompare(b.name));
}, [agents, searchTerm]); // Dependencies are primitives or stable references

// ❌ Bad - Creating new objects in render without memoization
return agents.filter(agent => agent.active).map(agent => ({
  ...agent,
  displayName: agent.name.toUpperCase()
}));
```

**Memoizing Objects and Arrays:**
```tsx
// ✅ Good - Stable object references
const defaultValues = useMemo(() => ({
  name: agent?.name || "",
  description: agent?.description || "",
  instructions: agent?.instructions || "",
}), [agent?.name, agent?.description, agent?.instructions]);

// ❌ Bad - New object created every render
const defaultValues = {
  name: agent?.name || "",
  description: agent?.description || "",
};
```

**useDeferredValue for Search Operations:**
```tsx
// ✅ Good - Use useDeferredValue for search to prevent blocking user input
import { useDeferredValue, useMemo, useState } from "react";

export function AgentSearch() {
  const [searchTerm, setSearchTerm] = useState("");
  const deferredSearchTerm = useDeferredValue(searchTerm);
  const { data: agents } = useAgents();

  // Search runs with deferred value, keeping input responsive
  const filteredAgents = useMemo(() => {
    if (!deferredSearchTerm) return agents;
    return agents?.filter(agent =>
      agent.name.toLowerCase().includes(deferredSearchTerm.toLowerCase()) ||
      agent.description?.toLowerCase().includes(deferredSearchTerm.toLowerCase())
    );
  }, [agents, deferredSearchTerm]);

  return (
    <>
      <Input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search agents..."
      />
      {filteredAgents?.map(agent => <AgentCard key={agent.id} agent={agent} />)}
    </>
  );
}

// ❌ Bad - Search blocks input on every keystroke
const filteredAgents = useMemo(() => {
  return agents?.filter(agent =>
    agent.name.toLowerCase().includes(searchTerm.toLowerCase())
  );
}, [agents, searchTerm]); // Runs on every keystroke, can block UI
```

### Data Flow and MCP Tools
Follow the established data patterns from MCP (Model Context Protocol) Tools:

**Consistent Data Fetching:**
```tsx
// ✅ Follow MCP patterns for data access
const { data: agents, isLoading } = useAgents();
const { data: integrations } = useIntegrations();
const { mutateAsync: updateAgent } = useUpdateAgent();

// Use proper loading states and error handling
if (isLoading) return <Spinner />;
```

### Design System Usage

**Always Use UI Components from @deco/ui:**
```tsx
// ✅ Good - Use design system components
import { Button } from "@deco/ui/components/button.tsx";
import { Input } from "@deco/ui/components/input.tsx";
import { Card, CardContent, CardHeader } from "@deco/ui/components/card.tsx";

// ❌ Bad - Creating custom components that duplicate design system
<button className="px-4 py-2 bg-blue-500 text-white rounded">
  Custom Button
</button>
```

### Form Management

**Prefer React Hook Form over useState:**
```tsx
// ✅ Good - Use react-hook-form with proper validation
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

const schema = z.object({
  email: z.string().email("Please enter a valid email address"),
  roleId: z.array(z.string()).min(1, "Please select a role"),
});

const form = useForm<FormData>({
  resolver: zodResolver(schema),
  defaultValues: { email: "", roleId: [] },
  mode: "onBlur", // Validate on blur for better UX
});

// ❌ Bad - Managing form state manually
const [email, setEmail] = useState("");
const [emailError, setEmailError] = useState("");
const [roleId, setRoleId] = useState([]);
```

**Avoid Prop Drilling with Form Context:**
```tsx
// ✅ Good - Use context for form sharing
const FormContext = createContext<UseFormReturn<FormData> | null>(null);

export function FormProvider({ children }: { children: ReactNode }) {
  const form = useForm<FormData>();
  return (
    <FormContext.Provider value={form}>
      {children}
    </FormContext.Provider>
  );
}

export function useFormContext() {
  const context = useContext(FormContext);
  if (!context) throw new Error("useFormContext must be used within FormProvider");
  return context;
}
```

**Use Design System Form Components:**
```tsx
// ✅ Good - Use form components with proper error handling
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@deco/ui/components/form.tsx";

<FormField
  control={form.control}
  name="email"
  render={({ field, fieldState }) => (
    <FormItem>
      <FormLabel>
        Email {isRequired && <span className="text-destructive ml-1">*</span>}
      </FormLabel>
      <FormControl>
        <Input 
          {...field} 
          className={fieldState.error ? "border-destructive focus-visible:ring-destructive" : ""}
        />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Component Architecture

**Single Responsibility Principle:**
```tsx
// ✅ Good - Focused, composable components
export function AgentCard({ agent }: { agent: Agent }) {
  return (
    <Card>
      <AgentHeader agent={agent} />
      <AgentContent agent={agent} />
      <AgentActions agent={agent} />
    </Card>
  );
}

function AgentHeader({ agent }: { agent: Agent }) {
  return (
    <CardHeader>
      <AgentAvatar agent={agent} />
      <div>
        <h3>{agent.name}</h3>
        <p>{agent.description}</p>
      </div>
    </CardHeader>
  );
}

// ❌ Bad - Monolithic component handling everything
export function AgentManager() {
  // 200+ lines of mixed concerns
  // - Data fetching
  // - UI rendering
  // - Form handling
  // - Business logic
}
```

**Composability and Reusability:**
```tsx
// ✅ Good - Composable avatar system
<AgentAvatar agent={agent} size="sm" />
<IntegrationAvatar integration={integration} size="lg" />
<UserAvatar user={user} size="default" />

// Components can be combined in different contexts
<Card>
  <div className="flex items-center gap-2">
    <AgentAvatar agent={agent} size="sm" />
    <span>{agent.name}</span>
  </div>
</Card>
```

### Dependency Array Best Practices

**Ensure Stable References:**
```tsx
// ✅ Good - Dependencies with stable references
const processedData = useMemo(() => {
  return data.map(item => transformItem(item));
}, [data]); // `data` comes from API hook with stable reference

const handleSubmit = useCallback((formData: FormData) => {
  mutateAsync(formData);
}, [mutateAsync]); // `mutateAsync` from react-query is stable

// ❌ Bad - Objects created inline in dependency array
const result = useMemo(() => {
  return processItems(items, options);
}, [items, { sortBy: 'name', order: 'asc' }]); // New object every render!

// ✅ Good - Memoize the options object
const options = useMemo(() => ({ sortBy: 'name', order: 'asc' }), []);
const result = useMemo(() => {
  return processItems(items, options);
}, [items, options]);
```

### Error Handling and Loading States

**Consistent Error and Loading Patterns:**
```tsx
// ✅ Good - Proper error and loading handling
export function AgentList() {
  const { data: agents, isLoading, error } = useAgents();

  if (isLoading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!agents?.length) return <EmptyState message="No agents found" />;

  return (
    <div className="space-y-4">
      {agents.map(agent => (
        <AgentCard key={agent.id} agent={agent} />
      ))}
    </div>
  );
}
```

### Real-Time State Management

**Immediate DOM Updates with Debounced State:**

For features that manipulate CSS or DOM directly (like theme editors, live previews):

```tsx
// ✅ Good - Immediate visual feedback with debounced persistence
export function ThemeEditor() {
  const form = useForm();
  const debounceTimerRef = useRef<number>();
  const previousValuesRef = useRef<Record<string, string>>({});

  // Clean up debounce timer on unmount
  useEffect(() => {
    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, []);

  const handleChange = (key: string, value: string) => {
    // 1. Store previous value for undo functionality
    const current = form.getValues(key);
    if (current) {
      previousValuesRef.current[key] = current;
    }

    // 2. Apply immediately to DOM for instant visual feedback
    document.documentElement.style.setProperty(key, value);

    // 3. Debounce form state update to reduce re-renders
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    
    debounceTimerRef.current = window.setTimeout(() => {
      form.setValue(key, value, { shouldDirty: true });
    }, 100);
  };

  const handleUndo = (key: string) => {
    const previousValue = previousValuesRef.current[key];
    if (previousValue) {
      document.documentElement.style.setProperty(key, previousValue);
      form.setValue(key, previousValue);
      delete previousValuesRef.current[key];
    }
  };

  return (
    <div>
      <Input onChange={(e) => handleChange("--primary", e.target.value)} />
      <Button onClick={() => handleUndo("--primary")}>Undo</Button>
    </div>
  );
}

// ❌ Bad - Every keystroke triggers full re-render
export function BadThemeEditor() {
  const [value, setValue] = useState("");
  
  return (
    <Input 
      value={value}
      onChange={(e) => {
        setValue(e.target.value);  // Triggers re-render
        document.documentElement.style.setProperty("--primary", e.target.value);
      }}
    />
  );
}
```

**Cross-Component Communication:**

Use custom events for coordinating updates across unrelated components:

```tsx
// Component A - Dispatch after mutation
export function SettingsForm() {
  const updateMutation = useUpdateSettings();

  const handleSave = async () => {
    await updateMutation.mutateAsync(data);
    
    // Notify other components of the update
    window.dispatchEvent(new CustomEvent("settings-updated"));
  };

  return <button onClick={handleSave}>Save</button>;
}

// Component B - Listen and react
export function SettingsPreview() {
  const queryClient = useQueryClient();

  useEffect(() => {
    const handleUpdate = () => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ["settings"] });
      
      // Or force immediate refetch
      queryClient.refetchQueries({ queryKey: ["settings"] });
    };
    
    window.addEventListener("settings-updated", handleUpdate);
    return () => {
      window.removeEventListener("settings-updated", handleUpdate);
    };
  }, [queryClient]);

  return <div>Preview updates automatically</div>;
}
```

**Undo/Redo Pattern:**

Implement single-level undo that reverts to the **saved state**, not the -1 change:

```tsx
export function ThemeEditor() {
  const { data: currentTheme } = useTheme();
  const form = useForm();
  const debounceTimerRef = useRef<number>();
  const previousValuesRef = useRef<Record<string, string>>({});

  // Reset previous values when saved theme changes
  useEffect(() => {
    form.reset({ themeVariables: currentTheme?.variables ?? {} });
    previousValuesRef.current = {};
  }, [currentTheme, form]);

  // Clean up debounce timer on unmount
  useEffect(() => {
    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, []);

  const handleChange = (key: string, newValue: string) => {
    // Store the ORIGINAL saved value only once
    // This way undo always reverts to the saved state, not the -1 change
    if (!(key in previousValuesRef.current)) {
      const savedValue = currentTheme?.variables?.[key];
      if (savedValue) {
        previousValuesRef.current[key] = savedValue;
      }
    }

    // Apply immediately to DOM
    document.documentElement.style.setProperty(key, newValue);
    
    // Debounce form update
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    debounceTimerRef.current = window.setTimeout(() => {
      form.setValue(key, newValue, { shouldDirty: true });
    }, 100);
  };

  const handleUndo = (key: string) => {
    const savedValue = previousValuesRef.current[key];
    if (savedValue) {
      // Revert to the saved theme value
      document.documentElement.style.setProperty(key, savedValue);
      form.setValue(key, savedValue);
      delete previousValuesRef.current[key];
    }
  };

  return (
    <div>
      <ColorPicker
        value={form.watch(key)}
        onChange={(val) => handleChange(key, val)}
        onUndo={() => handleUndo(key)}
        hasPreviousValue={!!(key in previousValuesRef.current)}
      />
    </div>
  );
}

// ❌ Bad - Undo only goes back one step, not to saved state
export function BadUndo({ value, onChange }: Props) {
  const previousValueRef = useRef<string>();

  const handleChange = (newValue: string) => {
    previousValueRef.current = value; // Overwrites on every change!
    onChange(newValue);
  };

  // This only undoes the last change, not all changes since last save
}
```

### AI Chat Context Integration

**Injecting Context into AI Threads:**

Use `useSetThreadContextEffect` to provide rules and tools to AI chat:

```tsx
import { useSetThreadContextEffect } from "../decopilot/thread-context-provider.tsx";

export function FeatureEditor() {
  // ✅ Good - Explicit union type for TypeScript
  const threadContextItems = useMemo<Array<
    { id: string; type: "rule"; text: string } | 
    { id: string; type: "toolset"; integrationId: string; enabledTools: string[] }
  >>(() => {
    const rules = [
      `You are helping configure feature settings.`,
      `Use FEATURE_UPDATE to modify settings.`,
      `Do NOT pass orgId - it will be auto-determined from context.`,
    ];

    const contextItems: Array<
      { id: string; type: "rule"; text: string } | 
      { id: string; type: "toolset"; integrationId: string; enabledTools: string[] }
    > = rules.map((text) => ({
      id: crypto.randomUUID(),
      type: "rule" as const,
      text,
    }));

    // Add feature management toolset
    contextItems.push({
      id: crypto.randomUUID(),
      type: "toolset" as const,
      integrationId: "i:feature-management",  // Virtual integration ID
      enabledTools: ["FEATURE_GET", "FEATURE_UPDATE"],
    });

    // Add HTTP fetch for external data
    contextItems.push({
      id: crypto.randomUUID(),
      type: "toolset" as const,
      integrationId: "i:http",
      enabledTools: ["HTTP_FETCH"],
    });

    return contextItems;
  }, []);

  // Inject into current thread
  useSetThreadContextEffect(threadContextItems);

  return <div>Feature editor UI</div>;
}

// ❌ Bad - TypeScript can't infer the union type correctly
const items = useMemo(() => {
  const rules = [/* ... */].map(text => ({ type: "rule", text }));
  rules.push({ type: "toolset", integrationId: "i:...", enabledTools: [] });
  // Type error: string[] not assignable to expected type
  return rules;
}, []);
```

**Extract Logic into Components Instead of Inline Functions:**
```tsx
// ❌ Bad - Using immediately invoked function expressions (IIFEs) in JSX
function UserProfile({ user }: { user: User }) {
  return (
    <div>
      <h2>{user.name}</h2>
      {(() => {
        if (user.isPremium) {
          return <Badge variant="gold">Premium</Badge>;
        }
        if (user.isActive) {
          return <Badge variant="green">Active</Badge>;
        }
        return <Badge variant="gray">Inactive</Badge>;
      })()}
      
      {(() => {
        const achievements = user.achievements.filter(a => a.isVisible);
        if (!achievements.length) return null;
        return (
          <div>
            {achievements.map(achievement => (
              <span key={achievement.id}>{achievement.name}</span>
            ))}
          </div>
        );
      })()}
    </div>
  );
}

// ✅ Good - Extract complex logic into separate components
function UserProfile({ user }: { user: User }) {
  return (
    <div>
      <h2>{user.name}</h2>
      <UserStatusBadge user={user} />
      <UserAchievements achievements={user.achievements} />
    </div>
  );
}

function UserStatusBadge({ user }: { user: User }) {
  if (user.isPremium) {
    return <Badge variant="gold">Premium</Badge>;
  }
  if (user.isActive) {
    return <Badge variant="green">Active</Badge>;
  }
  return <Badge variant="gray">Inactive</Badge>;
}

function UserAchievements({ achievements }: { achievements: Achievement[] }) {
  const visibleAchievements = achievements.filter(a => a.isVisible);
  
  if (!visibleAchievements.length) return null;
  
  return (
    <div>
      {visibleAchievements.map(achievement => (
        <span key={achievement.id}>{achievement.name}</span>
      ))}
    </div>
  );
}
```